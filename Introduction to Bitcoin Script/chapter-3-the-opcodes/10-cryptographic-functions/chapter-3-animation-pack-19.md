# Chapter 3 animation pack 19

Animate the following functions:

<table><thead><tr><th width="214">Word</th><th width="159">Input</th><th width="123">Output</th><th>Description</th></tr></thead><tbody><tr><td>OP_CHECKSIG</td><td>sig pubkey</td><td>True / false</td><td>Depending on the SIGHASH flag, some or all of the transaction's outputs, inputs, and script (from the most recently-executed OP_CODESEPARATOR to the end) are hashed. The signature used by OP_CHECKSIG must be a valid signature for this hash and public key. If it is, 1 is returned, 0 otherwise.</td></tr><tr><td>OP_CHECKSIGVERIFY</td><td>sig pubkey</td><td>nothing/fail</td><td>Same as OP_CHECKSIG, but OP_VERIFY is executed afterward.</td></tr><tr><td>OP_CHECKMULTISIG</td><td>x sig1 sig2 … &#x3C;no. signatures> pub1 pub2 &#x3C;no. public keys></td><td>True / False</td><td>Compares the first signature against each public key until it finds an ECDSA match. Starting with the subsequent public key, it compares the second signature against each remaining public key until it finds an ECDSA match. The process is repeated until all signatures have been checked or not enough public keys remain to produce a successful result. All signatures need to match a public key. Because public keys are not checked again if they fail any signature comparison, signatures must be placed in the scriptSig using the same order as their corresponding public keys were placed in the scriptPubKey or redeemScript. If all signatures are valid, 1 is returned, 0 otherwise. Due to a bug, an extra unused value (x) is removed from the stack. Script spenders must account for this by adding a junk value (typically zero) to the stack.</td></tr><tr><td>OP_CHECKMULTISIGVERIFY</td><td>x sig1 sig2 … &#x3C;no. signatures> pub1 pub2 &#x3C;no. public keys></td><td>nothing/fail</td><td>Same as OP_CHECKMULTISIG, but OP_VERIFY is executed afterward.</td></tr></tbody></table>
